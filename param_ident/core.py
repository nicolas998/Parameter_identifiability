# AUTOGENERATED! DO NOT EDIT! File to edit: 01_Virtual_data_setup.ipynb (unless otherwise specified).

__all__ = ['Get_sub_watersheds']

# Cell
def Get_sub_watersheds(watershed, order_max, order_min = 4):
    '''Obtains the sub-watersheds a different orders starting from the order_max and
    ending on the order_min, there is no return, it only updates the watershed.Table'''
    orders = np.arange(order_max, order_min, -1).tolist()
    for Prun in orders:
        #Finds the connections points
        Ho = Prun
        watershed.Table['prun_'+str(Ho)] = 0
        idx = watershed.Table.loc[watershed.Table['h_order']>=Ho].index
        for i in idx:
            size = watershed.Table.loc[(watershed.Table['dest'] == i) & (watershed.Table['h_order'] >= Ho-1)]
            if size.shape[0] >= 2:
                watershed.Table.loc[size.index, 'prun_'+str(Ho)] = 1

        #Finds all the links that belong to a pruning level
        idx = watershed.Table.loc[watershed.Table['prun_'+str(Ho)] == 1].sort_values(by = ['Acum'], ascending = False).index
        cont = 2
        for i in idx:
            #Finds the watershed upstream
            t = am.hlmModel(linkid=i)
            idx_t = watershed.Table.index.intersection(t.Table.index)
            #Assign that pruning level to the sub-watershed
            watershed.Table.loc[idx_t, 'prun_'+str(Ho)] = cont
            #Go to next pruning level
            cont += 1
        print('Prun %d done' % Prun)